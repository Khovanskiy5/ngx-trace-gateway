# Файл отвечает только за логирование:
# - map для уровней логов
# - map для разделения 4xx и 5xx по отдельным файлам
# - JSON-формат access.log

# map статуса HTTP-ответа в логический уровень severity.
# Это удобно для alerting: 2xx/3xx = info, 4xx = warn, 5xx = error.
map $status $log_level {
    ~^1   "info";   # 1xx информационные
    ~^2   "info";   # 2xx успех
    ~^3   "info";   # 3xx редиректы
    ~^4   "warn";   # 4xx ошибки клиента
    ~^5   "error";  # 5xx ошибки сервера / бэкенда
    default "info";
}

# map для выделения всех 4xx в отдельный лог-файл
map $status $log_4xx {
    ~^4   1;        # если статус начинается на 4 — логировать
    default 0;      # иначе нет
}

# map для выделения всех 5xx в отдельный лог-файл
map $status $log_5xx {
    ~^5   1;        # если статус начинается на 5 — логировать
    default 0;      # иначе нет
}

# Структурированный JSON-формат access.log.
# escape=json — говорит Nginx экранировать спецсимволы в значениях переменных,
# чтобы итоговая строка оставалась валидным JSON (экранируются кавычки, \n, \t и т.д.).
log_format structured_log escape=json
    '{'
        # timestamp: когда был обработан запрос

        # Человекочитаемая временная метка в формате ISO 8601 (UTC/локальное время с зоной),
        # удобна для просмотра логов «глазами» и для большинства систем логирования.
        '"timestamp":"$time_iso8601",'

        # Время в секундах с миллисекундами от начала UNIX-эпохи.
        # Удобно для точной корреляции между системами (метрики, трейсинг),
        # а также для сортировки и агрегации по времени без парсинга ISO‑строки.
        '"timestamp_msec":"$msec",'

        # severity и service: «метаданные» события и инстанса

        # Логический уровень важности события, мапится из HTTP‑статуса (через map $status $log_level):
        # например, 2xx/3xx -> "info", 4xx -> "warn", 5xx -> "error".
        # Нужен, чтобы алертить и фильтровать логи как в обычных лог-фреймворках (по уровню, а не по коду).
        '"severity":"$log_level",'

        # service — контекст сервиса/инстанса, полезен при сборе логов от множества сервисов.
        '"service":{'
            # Логическое имя сервиса: тут это просто "nginx", но можно менять (frontend-gateway, api-gateway и т.п.).
            '"name":"nginx",'
            # Имя инстанса/хоста (hostname контейнера/VM/pod), помогает понять, с какого узла пришёл лог.
            '"instance":"$hostname"'
        '},'

        # trace: поля для корреляции запросов между системами

        '"trace":{'

            # hop_name — логическое имя текущего hop'а (узла / роли) в цепочке.
            # Формируется в global_hop_name.conf на основе hostname или задается вручную
            # (например: "edge-nginx", "api-nginx", "internal-nginx").
            # Нужен, чтобы по логам сразу понимать, какой слой инфраструктуры
            # написал этот лог и какое место он занимает в цепочке прохождения запроса.
            '"hop_name":"$hop_name",'

            # hop_physical всегда отражает реальный узел/hostname.
            '"hop_physical":"$hop_physical",'

            # prev_request_id — идентификатор запроса с предыдущего hop'а (предыдущего прокси / сервиса).
            # Берётся из заголовка X-Prev-Request-ID, если он был передан внешней системой.
            # Нужен, чтобы понимать «кто был до нас» в цепочке прокси, даже если общий trace_id один и тот же.
            # Полезно при разборе сложных цепочек, когда важно увидеть конкретную последовательность hop'ов
            # и идентификатор запроса именно на предыдущем узле.
            '"prev_request_id":"$prev_request_id",'

            # local_request_id — локальный идентификатор запроса на уровне конкретного Nginx-узла.
            # Обычно берётся из $request_id. Уникален только в пределах одной машины/инстанса.
            # Логируется в Nginx и может пробрасываться в backend через заголовок (например, X-Local-Request-Id),
            # чтобы упростить поиск всех логов, связанных с обработкой одного запроса на этом узле.
            '"local_request_id":"$local_request_id",'

            # trace_request_id — сквозной (глобальный) идентификатор запроса.
            # Используется для корреляции логов между разными системами: Nginx, backend, очереди, микросервисы и т.д.
            # Логируется в Nginx и передаётся дальше в backend и другие сервисы через заголовок
            # (например, X-Trace-Id). По этому ID можно собрать «цепочку» прохождения запроса
            # по всей системе: от входа в Nginx до ответа последнего сервисa.
            '"trace_request_id":"$trace_request_id",'

            # Цепочка hop'ов: все прокси/шлюзы, через которые прошёл запрос,
            # в порядке прохождения (например: "edge:abc, api:def, internal:ghi").
            '"hops_chain":"$request_hops_chain",'

            # mobile_launch_id — идентификатор одного запуска мобильного приложения.
            # Приходит от мобильного клиента в заголовке X-Mobile-Launch-ID и живёт
            # с момента старта приложения до его полного закрытия.
            # Nginx сам этот идентификатор не генерирует, а только читает, логирует
            # и прозрачно проксирует дальше (см. global_trace.conf и app_trace_headers.conf).
            '"mobile_launch_id":"$mobile_launch_id",'

            # mobile_request_id — уникальный идентификатор одного HTTP‑запроса
            # мобильного приложения (X-Mobile-Request-ID).
            # Генерируется клиентом для каждого запроса и позволяет однозначно связать
            # сетевые ошибки/трейсы в мобильной аналитике и на backend'е.
            # Как и mobile_launch_id, в Nginx значение только принимается и прокидывается.
            '"mobile_request_id":"$mobile_request_id"'
        '},'

        # client: информация о клиенте (кто пришёл)

        '"client":{'
            # IP‑адрес клиента, как его видит Nginx (может быть IP балансировщика, если не настроен real_ip).
            '"ip":"$remote_addr",'
            # Порт клиента на его стороне TCP‑соединения.
            '"port":"$remote_port",'
            # Имя аутентифицированного пользователя (для HTTP basic auth и подобных механизмов),
            # чаще всего пусто, если аутентификация реализована на приложении.
            '"user":"$remote_user",'
            # Заголовок X-Forwarded-For (цепочка IP через прокси),
            # полезен для восстановления реального IP клиента в цепочке прокси.
            '"forwarded_for":"$http_x_forwarded_for",'
            # Реальный IP клиента после применения real_ip / set_real_ip_from (если настроено).
            # Если real_ip не настроен, обычно совпадает с $remote_addr.
            '"real_ip":"$realip_remote_addr"'
        '},'

        # network: информация о сетевом контексте на стороне сервера

        '"network":{'
            # Локальный IP сервера (адрес интерфейса, на который пришёл запрос).
            '"server_ip":"$server_addr",'
            # Локальный порт сервера (80, 443 и т.п.).
            '"server_port":"$server_port",'
            # Протокол HTTP на уровне TCP/HTTP (например, HTTP/1.1, HTTP/2.0),
            # значение из строки запроса.
            '"protocol":"$server_protocol",'

            # Вложенный объект connection — параметры TCP‑соединения между клиентом и Nginx.
            '"connection":{'
                # Уникальный идентификатор соединения в процессе Nginx.
                # Позволяет связать несколько запросов по одному TCP‑коннекту (keepalive).
                '"id":"$connection",'
                # Сколько запросов уже было обработано по этому соединению (keepalive‑счётчик).
                '"requests":"$connection_requests",'
                # Время жизни соединения (сколько оно открыто) в секундах.
                '"time":"$connection_time"'
            '},'

            # tcp: низкоуровневая TCP‑метрика (работает, если ядро/платформа поддерживает tcpinfo*)

            '"tcp":{'
                # RTT (round-trip time) — оценка времени «туда‑обратно» для пакета в миллисекундах.
                # Полезно для оценки сетевой латентности между Nginx и клиентом.
                '"rtt":"$tcpinfo_rtt",'
                # rttvar — вариация RTT (джиттер), показывает стабильность канала.
                '"rttvar":"$tcpinfo_rttvar",'
                # snd_cwnd — размер окна отправки TCP (congestion window),
                # косвенно отражает пропускную способность/качество канала.
                '"snd_cwnd":"$tcpinfo_snd_cwnd"'
            '}'
        '},'

        # tls: информация о TLS/SSL (если запрос по HTTPS)

        '"tls":{'
            # Флаг, что запрос пришёл по HTTPS (обычно "on" или пусто).
            '"enabled":"$https",'
            # Версия протокола TLS (например, TLSv1.2, TLSv1.3).
            '"protocol":"$ssl_protocol",'
            # Используемый шифр (cipher suite) — нужен для аудита безопасности и диагностики.
            '"cipher":"$ssl_cipher",'
            # Флаг, была ли переиспользована TLS‑сессия (session resumption),
            # влияет на производительность (меньше TLS‑handshake).
            '"session_reused":"$ssl_session_reused",'
            # Имя сервера (SNI), которое клиент указал при TLS‑handshake.
            # Важен при использовании одного IP для нескольких доменов.
            '"sni":"$ssl_server_name"'
        '},'

        # geo: географическая информация (если включён и настроен модуль GeoIP2)

        # Используем geoip2_* переменные, если настроен модуль GeoIP2.
        '"geo":{'
            # Двухбуквенный код страны по ISO (например, RU, US).
            # '"country":"$geoip2_country_code",'
            # Код региона/области (формат зависит от GeoIP‑базы).
            # '"region":"$geoip2_region_code"'
        '},'

        # http: всё, что связано с HTTP‑уровнем (запрос, ответ, сервер, upstream)

        '"http":{'
            # request: информация о входящем HTTP‑запросе
            '"request":{'
                # HTTP‑метод (GET, POST, PUT, DELETE и т.д.).
                '"method":"$request_method",'
                # Нормализованный URI (без аргументов), после внутреннего rewrite.
                # Удобен для агрегаций по конечным endpoint'ам.
                '"uri":"$uri",'
                # Исходный URI, как пришёл от клиента (с query‑строкой).
                '"uri_raw":"$request_uri",'
                # Путь до файла/ресурса (обычно совпадает с $uri, но без query).
                '"path":"$document_uri",'
                # Query‑параметры (часть после ?), в сыром виде.
                '"args":"$args",'
                # Схема — http или https (как видит Nginx).
                '"scheme":"$scheme",'
                # Имя хоста, к которому привязан server{} (ресолвится Nginx'ом).
                '"host":"$host",'
                # Заголовок Host, который прислал клиент (может отличаться от $host).
                '"host_header":"$http_host",'
                # Версия HTTP‑протокола (HTTP/1.0, HTTP/1.1, HTTP/2.0).
                '"http_version":"$server_protocol",'

                # headers: основные входящие HTTP‑заголовки
                '"headers":{'
                    # Referer — откуда пришёл пользователь (страница-источник).
                    '"referer":"$http_referer",'
                    # User-Agent — строка браузера/клиента, используется в аналитике и диагностике.
                    '"user_agent":"$http_user_agent",'
                    # Cookie — все cookie, пришедшие от клиента (может быть длинной строкой).
                    '"cookie":"$http_cookie"'
                '},'

                # size_bytes: размер всего HTTP‑запроса (строка запроса + заголовки + тело).
                '"size_bytes":"$request_length",'
                # Количество байт, принятых от клиента (включая тело запроса),
                # полезно для анализа входящего трафика.
                # '"body_bytes_received":"$bytes_received",'
                # Значение заголовка Content-Length (если было).
                '"content_length":"$content_length",'
                # Значение заголовка Content-Type (тип отправляемого клиентом контента).
                '"content_type":"$content_type"'
            '},'

            # response: информация о HTTP‑ответе, который Nginx отправил клиенту
            '"response":{'
                # HTTP‑статус ответа (200, 404, 500 и т.д.).
                '"status":$status,'
                # Время обработки запроса Nginx'ом от приёма до отправки последнего байта ответа (в секундах).
                # Ключевая метрика для latency/SLI.
                '"time_sec":"$request_time",'
                # Общее количество байт, отправленных клиенту (включая заголовки и тело).
                '"bytes_sent":$bytes_sent,'
                # Количество байт только в теле ответа (без заголовков).
                '"body_bytes_sent":$body_bytes_sent,'
                # Коэффициент сжатия gzip (отношение размера до/после), если включён gzip.
                '"gzip_ratio":"$gzip_ratio",'

                # headers: ключевые исходящие заголовки ответа
                '"headers":{'
                    # Тип содержимого, который фактически отправил Nginx клиенту (sent_http_*),
                    # может отличаться от того, что выдал upstream (если был изменён).
                    '"content_type":"$sent_http_content_type",'
                    # Content-Length, отправленный клиенту (может отсутствовать при chunked).
                    '"content_length":"$sent_http_content_length",'
                    # Дата, которую Nginx отправил в заголовке Date (момент формирования ответа).
                    '"date":"$sent_http_date",'
                    # Значение заголовка Connection, отправленного клиенту (keep-alive/close),
                    # полезно при диагностике обрывов соединений.
                    '"connection":"$http_connection"'
                '}'
            '},'

            # server: логический сервер (server_name), который обработал запрос

            '"server":{'
                # Имя virtual host (server_name), по которому был выбран блок server{}.
                # Нужен, чтобы различать несколько сайтов/доменов на одном Nginx.
                '"name":"$server_name"'
            '},'

            # upstream: информация о проксировании на backend (если запрос ходил в upstream)

            '"upstream":{'
                # Адрес(а) upstream‑сервера(ов), к которым обращался Nginx (IP:port или unix:socket).
                # При нескольких попытках может быть список, разделённый запятыми.
                '"address":"$upstream_addr",'
                # HTTP‑статус, возвращённый backend'ом (может отличаться от $status, если Nginx его переписал).
                '"status":"$upstream_status",'
                # Статус кэширования upstream‑ответа (HIT, MISS, BYPASS, EXPIRED и т.д.),
                # ключевой параметр для анализа работы proxy_cache.
                '"cache_status":"$upstream_cache_status",'
                # Количество байт, отправленных backend'у (запрос).
                '"bytes_sent":"$upstream_bytes_sent",'
                # Количество байт, полученных от backend'а (ответ).
                '"bytes_received":"$upstream_bytes_received",'
                # Длина ответа от upstream (как её видит Nginx).
                '"response_length":"$upstream_response_length",'
                # Количество попыток обратиться к разным backend'ам при failover.
                # '"upstream_tried":"$upstream_tried",'
                # timings: детализация времён взаимодействия с upstream

                '"timings":{'
                    # Время установления соединения к upstream (TCP connect), сек.
                    '"connect":"$upstream_connect_time",'
                    # Время до получения первых заголовков от upstream (TTFB от backend'а), сек.
                    '"header":"$upstream_header_time",'
                    # Полное время получения ответа от upstream (до последнего байта), сек.
                    '"response":"$upstream_response_time"'
                '},'

                # headers: важные заголовки, полученные от upstream

                '"headers":{'
                    # Значение заголовка Server от backend'а (его название/версия).
                    '"server":"$upstream_http_server",'
                    # Content-Type, который вернул upstream (до возможных модификаций Nginx).
                    '"content_type":"$upstream_http_content_type"'
                '}'
            '}'
        '},'

        # pipe: признак «pipeline»/спец‑обработки (исторический флаг Nginx),
        # обычно "p" для pipeline‑соединений, иначе точка. Может пригодиться для узкой диагностики.
        '"pipe":"$pipe"'
    '}';
