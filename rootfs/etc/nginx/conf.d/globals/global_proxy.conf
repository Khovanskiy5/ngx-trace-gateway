##
# GLOBAL PROXY — общие настройки проксирования для всех виртуальных хостов.
# Этот файл подключается в контексте
#   http {
#       ...
#       include /etc/nginx/conf.d/globals/global_proxy.conf;
#       ...
#   }, чтобы задать значения по умолчанию для proxy_* и связанных директив.
#
# При необходимости Вы можете переопределять эти значения
# в конкретных server { } и location { }.
# В Nginx действует правило: последняя директива в данном контексте имеет приоритет.
##

# Таймаут установления TCP-соединения до upstream.
proxy_connect_timeout 5s;

# Время ожидания ответа от upstream после отправки полного запроса.
proxy_read_timeout 10s;

# Время, в течение которого Nginx ожидает возможность отправить запрос upstream.
proxy_send_timeout 10s;

# Буферизация ответов от upstream.
# Включена по умолчанию для снижения нагрузки на backend и более ровной отдачи клиентам.
proxy_buffering on;

# Размер первичного буфера для ответа от upstream.
proxy_buffer_size 16k;

# Количество и размер дополнительных буферов для ответа от upstream.
proxy_buffers 16 16k;

# Размер «занятых» буферов, при превышении которого Nginx начнёт отдавать данные клиенту
# даже если ответ от upstream ещё не дочитан полностью.
proxy_busy_buffers_size 32k;

# Поведение при ошибках связи с upstream.
# error, timeout, при которых Nginx может попробовать
# обратиться к следующему серверу в upstream-группе.
proxy_next_upstream error timeout;

# Ограничение количества попыток перейти на следующий upstream-сервер.
proxy_next_upstream_tries 3;

# HTTP-версия 1.1 для поддержки keepalive и Upgrade (WebSocket и т.п.).
proxy_http_version 1.1;

# Временная директории для проксированных данных
proxy_temp_path /var/run/openresty/nginx-proxy;

# Геоинформация — закомментировано по умолчанию, т.к. geoip2 может быть не включён в образ.
# Раскомментировать при наличии модуля и БД GeoIP2.
# proxy_set_header X-Country $geoip2_country_code;
# proxy_set_header X-Region  $geoip2_region_code;

# X-Real-IP и X-Forwarded-For — стандартная схема передачи реального IP клиента.
# X-Forwarded-For содержит цепочку всех прокси.
proxy_set_header X-Real-IP       $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

# Дополнительный контекст для backend'а: схема и порт.
proxy_set_header Scheme      $scheme;
proxy_set_header SERVER_PORT $server_port;
proxy_set_header REMOTE_ADDR $remote_addr;

# Заголовки Upgrade и Connection — нужны для WebSocket и других протоколов.
# В http.conf настроена map $http_upgrade → $connection_upgrade (upgrade|close).
proxy_set_header Upgrade    $http_upgrade;
proxy_set_header Connection $connection_upgrade;

# Host передаём как есть, чтобы backend видел оригинальный домен и мог на нём строить логику.
proxy_set_header Host $host;

# Рекомендуемые стандартные заголовки X-Forwarded-*
# (для совместимости с типовыми фреймворками и обратными прокси).
proxy_set_header X-Forwarded-Proto $scheme;

# Предполагается, что в http { } заранее настроены map (см. global_trace.conf и technical-spec-tracing.md):
# - $trace_request_id      — сквозной trace ID (end‑to‑end идентификатор запроса);
# - $local_request_id      — локальный hop ID этого Nginx (уникален только на данном узле);
# - $prev_request_id       — hop ID предыдущего узла (из X-Prev-Request-ID, если он был);
# - $request_hops_chain    — нарастающая цепочка hop'ов в виде строки (edge:abc, api:def, ...);
# - $mobile_launch_id      — идентификатор запуска мобильного приложения (X-Mobile-Launch-ID);
# - $mobile_request_id     — идентификатор мобильного HTTP‑запроса (X-Mobile-Request-ID).
#

# Отдавать логическое имя узла (hop_name) клиенту и проксировать вниз в backend
add_header       X-HOP-Name $hop_name always;
proxy_set_header X-HOP-Name $hop_name;

# Сквозной trace ID, который живёт через всю цепочку сервисов:
# - если клиент или предыдущий hop уже прислал X-Request-ID, используем его;
# - если нет — Nginx сгенерировал свой $request_id и записал его в $trace_request_id.
# Здесь мы:
# 1) всегда возвращаем X-Request-ID клиенту (чтобы он видел свой trace ID и мог его логировать/передавать дальше);
# 2) пробрасываем X-Request-ID в backend, чтобы он использовал тот же идентификатор в своих логах и трейсах.
add_header       X-Request-ID $trace_request_id always;
proxy_set_header X-Request-ID $trace_request_id;

# Цепочка hop‑ID (X-Request-Chain):
# - содержит список всех промежуточных узлов/прокси и их локальных hop ID,
#   например: "edge:abc, api:def, internal:ghi";
# - на каждом Nginx к ней добавляется текущий hop (см. логику map в global_trace.conf).
# Здесь:
# 1) отдаём цепочку клиенту (для отладки и сложных сценариев трассировки);
# 2) передаём её дальше в backend/следующий Nginx, чтобы тот дополнил её своим hop'ом.
add_header       X-Request-Chain $request_hops_chain always;
proxy_set_header X-Request-Chain $request_hops_chain;

# Локальный hop‑ID этого Nginx (per-hop ID):
# - $local_request_id, как правило, равен $request_id и уникален в пределах данного инстанса Nginx;
# - для следующего звена цепочки он становится "предыдущим" (prev) hop ID.
# Поэтому вниз по цепочке мы отправляем X-Prev-Request-ID с нашим локальным ID —
# следующий Nginx увидит его как "кто был до меня".
proxy_set_header X-Prev-Request-ID $local_request_id;

# Для клиента в ответе возвращаем X-Prev-Request-ID со значением $prev_request_id:
# - это hop ID того узла, который стоял перед текущим Nginx в цепочке (если такой был);
# - позволяет при необходимости восстановить путь запроса не только вперёд (по hops),
#   но и назад, глядя на пару "prev_request_id" + "local_request_id" в логах разных узлов.
add_header       X-Prev-Request-ID $prev_request_id always;


# Мобильные идентификаторы (прозрачное проксирование):
# - X-Mobile-Launch-ID     (mobile_launch_id)     — один запуск мобильного приложения;
# - X-Mobile-Request-ID (mobile_request_id)    — один конкретный HTTP‑запрос мобильного клиента.
# Nginx не генерирует эти идентификаторы, а только:
# - читает их значения из входящих заголовков (через map в global_trace.conf);
# - логирует их (см. global_logging.conf);
# - всегда прокидывает дальше в backend/следующий hop и обратно клиенту, даже если значение пустое.
proxy_set_header X-Mobile-Launch-ID     $mobile_launch_id;
proxy_set_header X-Mobile-Request-ID $mobile_request_id;

add_header       X-Mobile-Launch-ID     $mobile_launch_id     always;
add_header       X-Mobile-Request-ID $mobile_request_id    always;


# Ключ кэша:
# - $scheme          — http/https
# - $request_method  — чтобы не кэшировать POST как GET
# - $host            — домен
# - $request_uri     — путь + query string
# - $http_authorization — чтобы не шарить кэш между разными токенами/юзерами
proxy_cache_key "$scheme$request_method$host$request_uri$http_authorization";

# Игнорируем некоторые заголовки origin, чтобы управлять кэшированием на стороне Nginx.
# Удобно, когда backend не умеет/не должен выставлять корректные Cache-Control/Expires.
proxy_ignore_headers Expires Cache-Control Set-Cookie Vary;

# Скрываем Set-Cookie из проксируемого ответа.
# Это позволяет кэшировать ответы, которые обычно считаются private из-за cookie.
# Использовать осторожно: нельзя так кэшировать персонализированные ответы.
# proxy_hide_header "Set-Cookie";

# proxy_cache_lock — защита от "thundering herd".
# Пока один запрос обновляет кэш (MISS), остальные будут ждать,
# вместо того чтобы одновременно грузить backend.
proxy_cache_lock on;
proxy_cache_lock_timeout 5s;  # сколько максимум ждать, пока лидер обновит кэш

# background_update — кэш обновляется в фоне, а пользователи получают старое значение,
# что снижает латентность и нагрузку на backend при истечении TTL.
proxy_cache_background_update on;

# revalidate — использовать If-Modified-Since / If-None-Match при обновлении кэша,
# если backend поддерживает ETag/Last-Modified.
proxy_cache_revalidate on;

# Время кэширования успешных ответов 200.
# Можно добавить и другие коды (302, 301, 404 и т.д. при необходимости).
proxy_cache_valid 200 1h;

# Только после 3-х обращений с одинаковым ключом объект будет закэширован —
# полезно для снижения кэша "шума" от редких запросов.
# proxy_cache_min_uses 3;

# Раздавать "старый" кэш, если backend падает или тормозит, повышая устойчивость.
# proxy_cache_use_stale proxy_cache_use_stale error timeout invalid_header updating http_500 http_502 http_503 http_504 http_403 http_404 http_429;

# Заголовок для отладки кэша на клиентах: HIT/BYPASS/MISS/EXPIRED и т.д.
add_header X-Proxy-Cache $upstream_cache_status always;

# Обратите внимание: все эти настройки являются значениями по умолчанию.
# В конкретных server { } / location { } Вы можете установить иные proxy_* параметры,
# которые будут переопределять глобальные значения для соответствующего контекста.

